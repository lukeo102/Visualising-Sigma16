## Stage 1 - Effective address competency and the original Sigma16 UI
Microsoft forms or similar

How easy did you find the Sigma16 UI to use when starting out with it? (0-10)
	Were there any elements of the UI that made it harder or easier to use? (Open text)

How easy did you find the Sigma16 UI to understand when starting out with it? (0-10)
	Were there any elements of the UI that made it harder or easier to understand what was going on? (Open text)

Can you describe how `load`, `lea`, and `store` work? (Discussion with me)
	If they cant or explain wrong, explain them
### Load explanation

| Address | Contents             | Label  |
| ------- | -------------------- | ------ |
| 0000    | load R1,data\[R0]    |        |
| 0002    | add R2,R1,R1         |        |
| 0003    | store R2,result\[R0] |        |
| 0005    | trap R0,R0,R0        |        |
| 0006    | 5                    | data   |
| 0007    | 0                    | result |
In the program above, `load` calculates the effective address by taking the address of data and adding the contents of `R0` to it
	data + R0
	0006 + 0000
	effective address = 0006
Then `load` takes the contents at the effective address and loads them into `R1`
### Lea explanation

| Address | Contents             | Label  |
| ------- | -------------------- | ------ |
| 0000    | lea R1,data\[R0]     |        |
| 0002    | add R2,R1,R1         |        |
| 0003    | store R2,result\[R0] |        |
| 0005    | trap R0,R0,R0        |        |
| 0006    | 5                    | data   |
| 0007    | 0                    | result |
In the program above, `lea` calculates the effective address by taking the address of data and adding the contents of `R0` to it
	data + R0
	0006 + 0000
	= 0006
Then `lea` stores the effective address into `R1`
### Store explanation

| Address | Contents             | Label  |
| ------- | -------------------- | ------ |
| 0000    | lea R1,data\[R0]     |        |
| 0002    | add R2,R1,R1         |        |
| 0003    | store R2,result\[R0] |        |
| 0005    | trap R0,R0,R0        |        |
| 0006    | 5                    | data   |
| 0007    | 0                    | result |
In the program above, `store` calculates the effective address by taking the address of result and adding the contents of `R0` to it
	result + R0
	0007 + 0000
	= 0007
Then `store` saves the contents of `R2` into that effective address
## Stage 2 - Using my project
Depending on the students ease of understanding

**Easy**
In case the student is really struggling, show them how `lea`, `load`, and `store` work in practice
	How they calculate the effective address
	Step through `Lea, Load, Store Showcase` to show the student how each instruction loads and stores values to and from registers
		Asking them to predict what will happen at each step

**Medium**
Square value stored in memory, then save it in the next memory address

Show the basics of how `load`, `lea`, and `store` work 

**Hard**
Pointers Pt. 1
	Ensure students know how `load` works by iterating over an array

Pointers Pt. 2
	Ensure students know how `lea` works by iterating over an array

Compare the difference between doing it with `load` and `lea`
	Step through each program with data flow open, ask student to predict what will happen in each block (pre-loop, loop), how many iterations the loop will go through, what memory will be changed
	Using `load` means you cant generalise the workflow into a function
	Using `lea` allows you to generalise the workflow by `lea`ing the start and end address of the array into 2 registers and jumping to the function

**Hard - Errors**
Array Sum
Students are to use my application to find and resolve errors in a array sum program
	Evaluate how effective my application is for finding errors
		Essentially leave the students to it, provide hints when asked
	Two errors will be reported by my program
		Line 2: `lee` instead of `lea`
		Line 11: on line 16 `loop` was changed to `l00p`, the error should make students look for where `loop` is meant to be used
	One error will not be reported, use of data flow will be required
		Line 6 and 7: 
			`&n` loaded into `R5` where it should be `&x`
			`&x` loaded into `R6` where it should be `&n`

**Expert**
Pointers Pt. 3
	Show how the difference between Pointers Pt. 1 and 2 can be used in practice
	Stepping through the program to show execution for each array 

## Stage 3 - Evaluation
Microsoft forms or similar

**Code runner**
Did you use the "Step Back" button in the code runner? (Yes/no)
	Was there anything specific that you liked or disliked about it? (Open text)
	How easy was it to see if it successfully stepped back through the program or not? (0-10)

How easy was it to figure out what line of code was just executed on the code runner? (0-10)

How easy was it to figure out what the next line of code would executed next on the code runner? (0-10)
	If low score, what would you change to make it easier? (Open text)

Was there anything you liked and/or disliked about the code runner? (Open text)

Is there anything that you would change about the code runner? (Open text)

**Data flow**
How easy or hard was the data flow window to understand than the processor tab from the Sigma 16 UI? (0-10)
	What elements made it harder to understand? (Open text)
	What elements made it easier to understand? (Open text)

Did you find limiting the amount of registers that are visible helpful? (Helpful/unhelpful scale) 
	Was there anything specific that made it helpful or unhelpful? (Open text)

Did you find limiting the amount of memory that is visible helpful? (Helpful/unhelpful scale) 
	Was there anything specific that made it helpful or unhelpful? (Open text)

Was there anything you liked and/or disliked about the data flow window? (Open text)

Is there anything that you would change about the data flow window? (Open text)

**Code editor**
How useful did you find the syntax highlighting? (0-10)
	What did you like or dislike about it? (Open text)

Was there anything with the code editor that you liked and/or disliked? (Open text)

**Overall ease of use**
How easy did you find my implementation to use? (0-10)
	Were there any elements of the UI that made it harder or easier to use? (Open text)

How easy did you find my implementation to understand? (0-10)
	Were there any elements of the UI that made it harder or easier to understand what was going on? (Open text)

Were there any elements of my implementation that made programming easier? (Open text)

Were there any elements of my implementation that made programming harder? (Open text)

Any other comments or observations about my implementation. (Open text)
